### 데이터 구조

---

#### 1. 순서가 있는 데이터 구조

* ##### 문자열(str)

  * `''`나 `""`를 활용하여 표기

  * immutable : 수정이 불가능하다

  * | 문법        | 설명                                                         |
    | ----------- | ------------------------------------------------------------ |
    | s.find(x)   | x의 첫 번째 위치를 반환. 없으면 -1 반환                      |
    | s.index(x)  | x의 첫 번째 위치를 반환. 없으면 오류 발생                    |
    | s.isalpha() | 알파벳 문자 여부<br />*단순 알파벳이 아닌 유니코드 상 Letter(한국어 포함) |
    | s.isupper() | 대문자 여부                                                  |
    | s.islower() | 소문자 여부                                                  |
    | s.istitle() | 타이틀 형식 여부(공백을 기준으로 다음 글자가 대문자이면 True 반환) |

  * **문자열 변경 메소드**

    | 문법                            | 설명                                                         |
    | ------------------------------- | ------------------------------------------------------------ |
    | s.replace(**old**, new[,count]) | 바꿀 대상글자를 새로운 글자로 바꿔서 반환                    |
    | s.strip([chars])                | 공백이나 특정 문자 제거                                      |
    | s.split([chars])                | 공백이나 특정 문자 기준으로 분리<br />선행후행 공백은 빈 문자열에 포함시키지 않음 |
    | 'separator'.join([iterable])    | 구분자로iterable을 합침                                      |
    | s.capitalize()                  | 가장 첫 번째 글자를 대문자로                                 |
    | s.title()                       | '나 공백 이후를 대문자로                                     |
    | s.upper()                       | 모두 대문자                                                  |
    | s.lower()                       | 모두 소문자                                                  |
    | s.swapcase()                    | 대<->소문자 변경                                             |

    ---

* ##### 리스트(list)

  * mutable : 가변형(list 요소 변경 가능)

  * | 문법                                         | 설명                                                         |
    | -------------------------------------------- | ------------------------------------------------------------ |
    | l.append(x)                                  | 리스트 마지막에 항목 x를 추가                                |
    | l.insert(i,x)                                | 리스트 인덱스 i에 항목 x를 삽입                              |
    | l.remove(x)                                  | 리스트 가장 왼쪽 항목(첫번째) x를 제거<br />항목이 존재하지 않을 경우 ValueError |
    | l.pop()                                      | 리스트 가장 오른쪽에 있는 항목(마지막)반환 후 제거           |
    | l.pop(i)                                     | 리스트 인덱스 i에 있는 항목을 반환 후 제거                   |
    | l.extend(m)                                  | 순회형 m으 ㅣ모든 항목들의 리스트 끝에 추가(+=와 같음)       |
    | l.index(x, start, end)                       | 리스트 항목 중 가장 왼쪽에 있는 x의 인덱스 반환              |
    | l.reverse()                                  | 리스트 순서를 반대로 뒤집음(정렬이 아님)                     |
    | l.sort()<br />-----------------<br />l.count | 리스트 정렬(매개변수 이용 가능)<br />---------------------------<br />리스트에서 항목 x가 몇개 존재하는지 갯수 반환 |

    ---

* ##### 튜플(tuple)

  * immutable
  * 변경 불가능하기 때문에, 값에 영향을 미치지 않는 메소드만을 지원
  * list 메소드 중 항목을 변경하는 메소드를 제외하고 대부분 동일

---

#### 2. 순서가 없는 데이터 구조

* ##### 셋(set)

  * mutable

  * 집합과 동일한 구조를 가짐. 집합 연산이 가능, 중복값 존재 x

  * | s.copy()       | 셋의 얕은 복사본을 반환                                      |
    | -------------- | ------------------------------------------------------------ |
    | s.add(x)       | 항목 x가 셋 s에 없다면 추가                                  |
    | s.pop()        | 셋 s에서 랜덤하게 항목을 반환하고(순서가 없기 때문에), 해당 항목을 제거<br />set이 비었을 경우 KeyError |
    | s.remove(s)    | 항목 x를 셋 s에서 삭제<br />항목이 존재하지 않을 경우 KeyError |
    | s.discard(x)   | 항목 x가 셋 s에 있는 경우, 항목 x를 셋 s에서 삭제            |
    | s.update(t)    | 셋 t에 있는 모든 항목 중 셋 s에 없는 항목을 추가             |
    | s.clear()      | 모든 항목을 제거                                             |
    | s.isdisjoint() | 셋 s가 셋 t의 서로 같은 항목을 하나라도 갖고 있지 않은 경우 True 반환 |
    | s.issubset()   | 셋 s가 셋 t의 하위 셋인 경우, True 반환                      |
    | s.issuperset() | 셋 s가 셋 t의 상위 셋인 경우, True 반환                      |

  ---

* ##### 딕셔너리(dict)

  * 순서 없이 키-값 쌍으로 이뤄진 자료형

  * | d.clear()    | 모든 항목을 제거                                             |
    | ------------ | ------------------------------------------------------------ |
    | d.copy()     | 딕셔너리 d 의 얕은 복사본을 반환                             |
    | d.keys()     | 딕셔너리 d의 모든 키를 담은 뷰를 반환                        |
    | d.values()   | 딕셔너리 d의 모든 값을 담은 뷰를 반환                        |
    | d.items()    | 딕서너리 d의 모든 키-값의 쌍을 담은 뷰 반환                  |
    | d.get(k)     | 키 k의 값을 반환하는데, k가 없을 경우 None 반환              |
    | d.get(k,v)   | 키 k의 값을 반환하는데, k가 없을 경우 v 반환                 |
    | d.pop(k)     | 키 k의 값을 반환하고, 키 k인 항목을 딕셔너리 d에서 삭제하는데,<br />키 k가 딕셔너리 d에 없을 경우 KeyError발생 |
    | d.pop(k,v)   | 키 k의 값을 반환하고, 키 k인 항목을 딕셔너리 d에서 삭제하는데,<br />키 k가 딕셔너리 d에 없을 경우 v 반환 |
    | d.update(..) | 딕셔너리 d의 값을 매핑하여 업데이트                          |

---

#### 3. 복사방법

* **할당**

  * 대입 연산자 `=`

  * **이렇게 같은 객체를 바라보기 때문에 함께 변함**

  * ```python
    original_list = [1,2,3]
    copy_list = original_list
    print(original_list, copy_list)
    #=> [1,2,3] [1,2,3]
    copy_list[0] = 'hello'
    print(original_list, copy_list)
    #=> ['hello',2,3] ['hello',2,3]
    ```

  * **이를 막기 위해서는** 슬라이싱 또는 list화 해야함

  * ```python
    original_list = [1,2,3]
    copy_list = original_list[:]
    #or
    #copy_list = list(original_list)
    print(original_list, copy_list)
    #=> [1,2,3] [1,2,3]
    copy_list[0] = 'hello'
    print(original_list, copy_list)
    #=> [1,2,3] ['hello',2,3]
    ```

* **얕은 복사**

  * 2차원 구조와 같은 상태에서 복사하는 리스트가 같은 객체를 참조하는 경우

  * ```python
    a = [1,2,['a','b']]
    b = a[:]
    print(a,b)
    b[2][0] = 0
    print(a,b)
    #=> [1,2,['a','b']] [1,2,['a','b']]
    #=> [1,2,[0,'b']] [1,2,[0,'b']]
    ```

* **깊은 복사**

  * 얕은 복사를 해결하기 위해선 `import copy` - `deepcopy` 사용

  * ```python
    import copy
    a = [1,2,['a','b']]
    b = copy.deepcopy(a)
    print(a,b)
    b[2][0] = 0
    print(a,b)
    #=> [1,2,['a','b']] [1,2,['a','b']]
    #=> [1,2,['a','b']] [1,2,[0,'b']]
    ```

  * 

