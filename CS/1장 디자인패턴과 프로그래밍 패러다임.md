# 디자인 패턴과 프로그래밍 패러다임

## 1.1 디자인 패턴

+ 디자인 패턴이란 프로그램 설계시 발생했던 문제점들을 객체간 상호 관계 등을 이용하여 해결할 수 있도록 하나의 '규약'으로 만들어 놓은 것

### 1.1.1 싱글톤 패턴

+ 하나의 클래스에 오직 하나의 인스턴스만 가지는 패턴(DB 연결 모듈에 많이 사용)

+ 하나의 인스턴스를 만들어 놓고 해당 인스턴스를 다른 모듈이 공유하며 사용

+ 장점 : 인스턴스 생성 비용이 줄어듦

+ 단점 : 의존성이 높아짐

  #### 자바스크립트 싱글톤 패턴

  ```javascript
  // 자바스크립트에서 {} 또는 new Object로 객체를 생성할 경우 다른 어떤 객체와도 같지 않기 때문에 이 자체만으로 싱글톤 패턴 구현이 가능하다
  
  const obj = {
      a : 27
  }
  const obj2 = {
      a : 27
  }
  console.log(obj === obj2)
  // false
  // 이처럼 서로 다른 인스턴스를 가진다
  ```

  ```javascript
  // 실제 예시
  class Singleton {
      constructor(){
          if (!Singleton.instance){
              Singleton.instance = this
          }
          return Singleton.instance
      }
      getInstance(){
          return this.instance
      }
  }
  
  const a = new Singleton()
  const b = new Singleton()
  console.log(a === b) 
  // true
  ```

  #### 데이터베이스 연결 모듈 예시

  ```javascript
  // DB 연결을 하는 것이기 때문에 비용이 더 높은 작업 
  const URL = 'mongodb://localhost:27017/kundolapp' 
  const createConnection = url => ({"url" : url})    
  class DB {
      constructor(url) {
          if (!DB.instance) { 
              DB.instance = createConnection(url)
          }
          return DB.instance
      }
      connect() {
          return this.instance
      }
  }
  const a = new DB(URL)
  const b = new DB(URL) 
  console.log(a === b) // true
  
  // URL 상수에는 연결할 MongoDB 데이터베이스의 URL이 저장되어 있습니다.
  
  // createConnection 함수는 URL을 인자로 받아 해당 URL을 가진 객체를 반환합니다.
  
  // DB 클래스의 생성자는 이전에 클래스의 인스턴스가 있는지 확인하고, 없으면 createConnection 함수를 사용하여 새로운 인스턴스를 만들고 instance라는 정적 변수에 저장합니다. 이미 클래스의 인스턴스가 있는 경우, 해당 인스턴스를 반환합니다.
  
  // DB 클래스의 connect 메소드는 instance 변수를 반환하여 MongoDB 연결 정보를 가져옵니다.
  ```

  #### 싱글톤 패턴의 단점

  + TDD(Test Driven Development) 할 때 걸림돌이 된다.

    + TDD시 단위 테스트를 주로 하는데 단위 테스트는 서로 독립적이어야하며 테스트를 어떤 순서로든 실행할 수 있어야한다. 하지만 싱글톤은 미리 생성된 하나의 인스턴스를 기반으로 구현하기 때문에 '독립적' 인스턴스 만들기가 어렵다

  + 모듈간 결합을 강하게 만든다.

    + **'의존성 주입(DI, Dependency Injection)'**을 통해 해결 가능

    + **'의존성 주입(DI, Dependency Injection) 원칙'**

      + "상위 모듈은 하위 모듈에서 어떠한 것도 가져오지 않아야한다. 또한, 둘 다 추상화에 의존해야하며, 이때 추상화는 세부 사항에 의존하지 말아야 한다"

      ![image-20230411153536560](1장 디자인패턴과 프로그래밍 패러다임.assets/image-20230411153536560.png)

      이처럼 메인 모듈이 '직접' 하위 모듈에 의존성을 주기보다 중간에 의존성 주입자를 넣어 '간접'적으로 의존성을 주입하는 방식. 이를 **'디커플링이 된다'** 라고 표현

      |                       의존성 주입 장점                       |                      의존성 주입 단점                       |
      | :----------------------------------------------------------: | :---------------------------------------------------------: |
      |                     모듈 쉽게 교체 가능                      | 모듈이 더욱더 분리되어 <br />클래스 수가 늘어나 복잡성 증가 |
      |                 테스팅과 마이그레이션 쉬워짐                 |                 약간의 런타임 패널티가 생김                 |
      | 어플리케이션 의존성 방향이 일관되고 <br />모듈간 관계가 조금 더 명확해짐 |                                                             |

      

### 1.1.2 팩토리 패턴

+ 객체 생성 부분을 떼어내 추상화한 패턴, 객체 생성 로직이 분리되어 리팩토링하더라도 한 곳만 고치면 되니 유지 보수성 증가

+ 상속 관계에 있는 두 클래스에서 상위 클래스가 중요 뼈대를 결정하고 하위 클래스에서 객체 생성에 관한 구체적인 내용을 결정하는 패턴

+ 상위 클래스와 하위 클래스로 나뉘어 느슨한 결합을 가지며 상위 클래스는 인스턴스 생성방식에 대해 알 필요가 없어 더욱 유연성을 가짐

  #### 자바스크립트 팩토리 패턴

  ```javascript
  // 간단하게 new Object()로 구현 가능
  const num = new Object(42)
  const str = new Object('abc')
  num.constructor.name; // Number
  str.constructor.name; // String
  
  // 숫자나 문자열을 전달함에 따라 다른 타입의 객체를 생성하는 모습. 즉, 전달받은 값에 따라 다른 객체를 생성하며 인스턴스의 타입을 정한다
  ```

  ```javascript
  // 커피 팩토리가 상위 클래스로 중요 뼈대 결정
  class CoffeeFactory {
      static createCoffee(type) {
          const factory = factoryList[type]
          return factory.createCoffee()
      }
  }   
  class Latte {
      constructor() {
          this.name = "latte"
      }
  }
  class Espresso {
      constructor() {
          this.name = "Espresso"
      }
  } 
  
  // 하위 클래스가 구체적 내용 결정
  class LatteFactory extends CoffeeFactory{
      static createCoffee() {
          return new Latte()
      }
  }
  class EspressoFactory extends CoffeeFactory{
      static createCoffee() {
          return new Espresso()
      }
  }
  const factoryList = { LatteFactory, EspressoFactory } 
   
   
  const main = () => {
      // 라떼 커피를 주문한다.  
      const coffee = CoffeeFactory.createCoffee("LatteFactory")  
      // 커피 이름을 부른다.  
      console.log(coffee.name) // latte
  }
  main()
  
  // CoffeeFactory 클래스는 커피를 생성하는 팩토리를 생성하는 클래스입니다. createCoffee 메소드를 가지고 있으며, 이 메소드는 factoryList 객체에서 주어진 type 인자에 따라 적절한 팩토리를 찾아서 해당 팩토리로부터 커피를 생성하고 반환합니다.
  
  // Latte 클래스와 Espresso 클래스는 각각 라떼와 에스프레소 커피를 나타내는 클래스입니다. 이들 클래스는 CoffeeFactory 클래스를 상속받지 않습니다.
  
  // LatteFactory 클래스와 EspressoFactory 클래스는 각각 라떼와 에스프레소 커피를 생성하는 팩토리 클래스입니다. 이들 클래스는 CoffeeFactory 클래스를 상속받고, createCoffee 메소드를 구현합니다. createCoffee 메소드에서는 각각 Latte 클래스와 Espresso 클래스를 생성하여 반환합니다.
  
  // 마지막으로, factoryList 객체에는 LatteFactory 클래스와 EspressoFactory 클래스가 저장되어 있습니다.
  
  // main 함수에서는 CoffeeFactory.createCoffee 메소드를 사용하여 라떼 커피를 주문하고, 이를 coffee 변수에 저장합니다. console.log 함수를 사용하여 coffee 변수의 name 속성을 출력합니다. 출력 결과는 latte가 됩니다.
  ```

  위 코드는 의존성 주입으로도 볼 수 있다. CoffeeFactory에서 LatteFactory의 인스턴스를 생성하는게 아니라 LatteFactory에서 생성한 인스턴스를 CoffeeFactory에 주입하고 있기 때문

  

### 1.1.3 전략 패턴(정책 패턴)

* 객체의 행위를 바꾸고 싶은 경우 '직접' 수정하지 않고 전략이라 부르는 '캡슐화한 알고리즘'을 컨텐스트 안에서 바꿔주면서 상호 교체가 가능하게 만드는 패턴

  #### passport의 전략 패턴[전략 패턴을 활용한 라이브러리]

  ![image-20230411172906610](1장 디자인패턴과 프로그래밍 패러다임.assets/image-20230411172906610.png)

  * passport는 Node.js에서 인증 모듈을 구현할 때 쓰는 미들웨어 라이브러리로, 여러 '전략'을 기반으로 인증할 수 있게 해준다.
  * 서비스 내 회원가입된 아이디와 비밀번호를 기반으로 인증하는 LocalStrategy 전략과 페이스북, 네이버 등 타 서비스 기반으로 인증하는 OAuth 전략 등을 지원한다

  ```javascript
  var passport = require('passport')
      , LocalStrategy = require('passport-local').Strategy;
  
  passport.use(new LocalStrategy(
      function(username, password, done) {
          User.findOne({ username: username }, function (err, user) {
            if (err) { return done(err); }
              if (!user) {
                  return done(null, false, { message: 'Incorrect username.' });
              }
              if (!user.validPassword(password)) {
                  return done(null, false, { message: 'Incorrect password.' });
              }
              return done(null, user);
          });
      }
  ));
  
  // 먼저, passport 모듈과 LocalStrategy를 require 함수를 사용하여 가져옵니다.
  
  // passport.use 함수를 호출하여 LocalStrategy를 등록합니다. 이 함수는 콜백 함수를 인자로 받습니다. 이 콜백 함수는 로컬 인증에 사용되는 로직을 구현합니다.
  
  // 콜백 함수는 username, password, done 매개변수를 받습니다. done 함수는 인증이 성공하거나 실패했을 때 호출되는 함수입니다.
  
  // User.findOne 메소드를 사용하여 username에 해당하는 사용자를 데이터베이스에서 찾습니다. 이 메소드는 콜백 함수를 인자로 받습니다. 콜백 함수는 에러와 사용자 객체를 받습니다.
  
  // findOne 메소드에서 에러가 발생하면 done 함수를 호출하여 해당 에러를 처리합니다.
  
  // 사용자 객체가 존재하지 않는 경우 done 함수를 호출하여 사용자 인증에 실패했음을 알립니다.
  
  // 사용자 객체가 존재하는 경우, user.validPassword(password)를 호출하여 입력된 비밀번호가 맞는지 확인합니다. 만약 비밀번호가 맞지 않는 경우 done 함수를 호출하여 사용자 인증에 실패했음을 알립니다.
  
  // 인증이 성공한 경우 done 함수를 호출하여 null과 사용자 객체를 반환합니다. 이후에 passport.serializeUser 함수를 사용하여 사용자 객체를 세션에 저장합니다.
  ```

  

### 1.1.4 옵저버 패턴

※ [옵저버 패턴 참고 블로그](https://velog.io/@haero_kim/%EC%98%B5%EC%A0%80%EB%B2%84-%ED%8C%A8%ED%84%B4-%EA%B0%9C%EB%85%90-%EB%96%A0%EB%A8%B9%EC%97%AC%EB%93%9C%EB%A6%BD%EB%8B%88%EB%8B%A4)

* 주체가 어떤 객체의 상태가 변하면 메서드 등을 통해 옵저버들에게 변화를 알려주는 디자인 패턴

* 주체 : 객체의 상태 변화를 보고 있는 관찰자 / 옵저버 : 객체의 상태 변화에 따라 전달되는 메서드를 기반으로 '추가 변화 사항'이 생기는 객체

* 옵저버 패턴은 다른 객체의 상태 변화를 감지함에 있어 객체끼리 느슨하게 결합되는 형태이기에 의존성을 제거하고 시스템을 보다 유연하게 해주는 효과가 있다. 

* 또한 상태변화를 감시하는 객체에게 직접 알리는 것이 아니기 때문에 불필요한 코드를 줄이는 효과가 있

  <img src="https://velog.velcdn.com/images/tiger/post/e8475580-cff5-4362-a639-550cbfae627f/image.png" alt="img" style="zoom:50%;" />

  아래 그림처럼 주체와 객체를 합쳐 구축하기도 한다.

  <img src="https://velog.velcdn.com/images/tiger/post/a1f8739b-f244-48fe-aa6c-cc50dc15a8d4/image.png" alt="img" style="zoom:50%;" />

  ​	

  ※ 트위터는 옵저버 패턴을 활용한 서비스

  <img src="https://velog.velcdn.com/images/tiger/post/cf92621d-b9e2-44a4-a48d-44902b2c909c/image.png" alt="img" style="zoom:50%;" />

  #### 자바스크립트 옵저버 패턴

  * 자바스크립트에서 옵저버 패턴은 프록시 객체를 통해 구현할 수도 있음

  * **프록시객체란?** [JS 프록시 MDN](https://developer.mozilla.org/ko/docs/Web/JavaScript/Reference/Global_Objects/Proxy)

    * 어떠한 대상의 기본 동작(속성 접근, 할당, 순회, 열거, 함수 호출)을 가로챌 수 있는 객체를 뜻하며, 자바스크립트에서 프록시 객체는 두 개의 매개 변수를 가짐
      * target : 프록시할 대상
      * handler : target 동작을 가로채고 어떠한 동작을 할 것인지 설정되어있는 함수

    ```javascript
    const handler = {
        get : function(target, name) {
            return name === 'name' ? '${target.a} ${target.b}' : target[name]
        }
    }
    const p = new Proxy({a: 'KUNDOL', b:'IS AUMUMU ZANGIN'}, handler)
    console.log(p.name) 
    // KUNDOL IS AUMUMU ZANGIN
    ```

    #### JS의 프록시 객체를 통한 옵저버 패턴 구현
    
    ```javascript
    function createReactiveObject(target, callback) { 
        const proxy = new Proxy(target, {
            set(obj, prop, value){
                if(value !== obj[prop]){
                    const prev = obj[prop]
                    obj[prop] = value 
                    callback(`${prop}가 [${prev}] >> [${value}] 로 변경되었습니다`)
                }
                return true
            }
        })
        return proxy 
    } 
    const a = {
        "형규" : "솔로"
    } 
    const b = createReactiveObject(a, console.log)
    b.형규 = "솔로"
    b.형규 = "커플"
    // 형규가 [솔로] >> [커플] 로 변경되었습니다
    
    // 위 코드는 리액티브한 객체를 생성하는 함수인 createReactiveObject를 정의하고, 이를 이용하여 객체 a에 대한 프록시 객체 b를 생성하는 예시입니다.
    
    // createReactiveObject 함수는 주어진 객체 target에 대한 프록시 객체를 생성합니다. 이 프록시 객체는 set 핸들러를 가지며, 객체의 프로퍼티가 변경될 때마다 콜백 함수 callback이 호출되도록 합니다.
    
    // 예시에서는 객체 a에 대해 createReactiveObject 함수를 호출하여 b를 생성하였습니다. b 객체의 형규 프로퍼티에 값을 할당할 때마다, set 핸들러가 호출되어 값이 변경되었음을 콘솔에 출력합니다.
    ```
  
  #### Vue.js 3.0의 옵저버 패턴
  
  ![image-20230411184412629](1장 디자인패턴과 프로그래밍 패러다임.assets/image-20230411184412629.png)
  
  ```javascript
  function createReactiveObject(
  	target: Target,
      isReadonly: boolean,
      baseHandlers: ProxyHandler<any>,
      collectionHandlers: ProxyHandler<any>,
      proxyMap: WeakMap<Target, any>
  ){
          if (!isObject(target)){
              if (__DEV__){
                  console.warn(`value cannot be made reactive: ${String(target)}`)
              }
              return target
          }
          
          // target is already a Proxy, return it.
          // exception: calling readonly() on a reactive object
          if(
          	target[ReactiveFlags.RAW] &&
              !(isReadonly && target[ReactiveFlags.IS_REACTIVE])
          ){
              return target
          }
          // target already has corresponding Proxy
          const existingProxy = proxyMap.get(target)
          if (existingProxy){
              return existingProxy
          }
          // only a whitelist of value types can be observed.
          const targetType = getTargetType(target)
          if (targetType == TargetType.INVALID){
              return target
          }
          const proxy = new Proxy(
          	target,
          	targetType === TargetType.COLLECTION ? collectionHandelers : baseHandlers
          )
          proxyMap.set(target, proxy)
          return proxy
      }
  
  // 이 함수는 프락시(Proxy)를 사용하여 객체의 상태 변화를 감지합니다. 프락시란 다른 객체에 대한 인터페이스를 제공하면서 그 객체에 대한 접근을 제어하는 객체입니다. 이 함수에서는 타겟 객체(target)와 함께 프락시 객체(proxy)를 생성합니다.
  
  // 함수의 첫 번째 인수는 타겟 객체이고, 두 번째 인수는 읽기 전용 여부(isReadonly)를 나타냅니다. 세 번째와 네 번째 인수는 각각 베이스 핸들러(baseHandlers)와 컬렉션 핸들러(collectionHandlers)입니다. 베이스 핸들러는 객체에 대한 기본적인 프락시 동작을 수행하고, 컬렉션 핸들러는 컬렉션(배열, 맵 등)에 대한 프락시 동작을 수행합니다. 마지막 인수인 프락시 맵(proxyMap)은 타겟 객체와 그에 해당하는 프락시 객체를 저장하는 데 사용됩니다.
  
  // 먼저, 타겟 객체가 객체인지 확인합니다. 그렇지 않으면 함수는 타겟 객체를 그대로 반환합니다. 그리고 타겟 객체가 이미 프락시 객체인 경우에는, 읽기 전용 여부(isReadonly)와 상관없이 프락시 객체를 그대로 반환합니다. 하지만 만약 읽기 전용 여부(isReadonly)가 true인 경우에는, 이미 리액티브인 경우에도 다시 프락시를 만들어 반환합니다.
  
  // 만약 타겟 객체가 리액티브 객체가 아닌 경우, getTargetType 함수를 사용하여 객체의 타입(TargetType)을 확인합니다. 이때 타겟 객체의 타입이 TargetType.INVALID인 경우, 함수는 타겟 객체를 그대로 반환합니다. 하지만 유효한 타겟 객체인 경우, 프락시 객체(proxy)를 생성하여 반환합니다.
  
  // 마지막으로, 생성된 프락시 객체를 프락시 맵(proxyMap)에 저장합니다. 이렇게 하면 같은 타겟 객체에 대해 두 번 이상 리액티브 객체를 만들어도, 항상 같은 프락시 객체를 반환할 수 있습니다.
  ```
  
  



## 1.2 프로그래밍 패러다임





## 1.3 기타 용어

#### 라이브러리 

+ 공통으로 사용될 수 있는 특정 기능을 모듈화 한 것. 규칙이 없고 프레임워크에 비해 자유로움

#### 프레임워크

+ 공통으로 사용될 수 있는 특정 기능을 모듈화 한 것. 폴더명, 파일명 등에 규칙이 있고 라이브러리에 비해 엄격함

#### Enum

+ 상수 집합을 정의할 때 사용되는 타입, 상수 뿐만 아니라 메서드르 ㄹ집어넣어 관리할 수도 있다. Enum을 사용할 경우 리팩토링시 상수 집합에 대한 로직 수정시 이 부분만 수정하면 되는 장점이 있고, 본질적으로 시스레드세이프하기 떄문에 싱글톤 패턴을 만들 때 도움이 된다

#### 컨텍스트

* 개발자가 어떠한 작업을 완료하는데 필요한 모든 관련 정보

#### 상속과 구현

+ 상속 :  자식 클래스가 부모 클래스의 메서드를 상속받아 사용하며 추가 및 확장을 할 수 있는 것. 이로 인해 재사용성, 중복성이 최소화됨
+ 구현 : 부모 인터페이스를 자식 클래스에서 재정의하여 구현하는 것. 상속과 달리 반드시 재정의하여 구현해야함
+ 상속은 일반 클래스, abstract 클래스를 기반으로 구현하고, 구현은 인터페이스를 기반으로 구현함

#### DOM(Document Object Model)

+ 문서 객체 모델을 말하며, 웹 브라우저상의 화면을 이루고 있는 요소들을 지칭
